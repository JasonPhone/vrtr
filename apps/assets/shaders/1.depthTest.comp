#version 450
#extension GL_EXT_shader_atomic_float : require
#extension GL_EXT_shader_atomic_float2 : require
layout(local_size_x = 4, local_size_y = 4)in;
// layout(local_size_x = 16, local_size_y = 16)in;
// layout(local_size_x = 80, local_size_y = 45)in;

layout(set = 0, binding = 0)buffer InputBuffer0 {
  float data[];
} input_0;
layout(set = 0, binding = 1)buffer InputBuffer1 {
  float data[];
} input_1;
layout(set = 0, binding = 2)buffer InputBuffer2 {
  float data[];
} input_2;

layout(set = 1, binding = 0)buffer OutputBuffer0 {
  float data[];
} output_0;

layout(push_constant)uniform PushConstants {
  vec4 data1;
  vec4 data2;
  vec4 data3;
  vec4 data4;
} constants;

ivec3 kBufferSize = ivec3(constants.data1.xyz);
ivec3 kGroupSize = ivec3(gl_WorkGroupSize);
ivec3 kGroupNum = ivec3(gl_NumWorkGroups);
ivec3 kGroupId = ivec3(gl_WorkGroupID);
ivec3 kLocalId = ivec3(gl_LocalInvocationID);
// Current working element.
ivec3 kGlobalId = ivec3(gl_GlobalInvocationID);

int indexBuffer(int wi, int hi) {
  wi = min(1279, max(0, wi));
  hi = min(719, max(0, hi));
  return hi * kBufferSize.x * kBufferSize.z + wi * kBufferSize.z;
}

vec4 readBuffer0(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_0.data[idx + 0],
    input_0.data[idx + 1],
    input_0.data[idx + 2],
    input_0.data[idx + 3]
  );
}
vec4 readBuffer1(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_1.data[idx + 0],
    input_1.data[idx + 1],
    input_1.data[idx + 2],
    input_1.data[idx + 3]
  );
}
vec4 readBuffer2(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_2.data[idx + 0],
    input_2.data[idx + 1],
    input_2.data[idx + 2],
    input_2.data[idx + 3]
  );
}
void writeBuffer(int wi, int hi, vec4 val) {
  int idx = indexBuffer(wi, hi);
  output_0.data[idx + 0] = val.x;
  output_0.data[idx + 1] = val.y;
  output_0.data[idx + 2] = val.z;
  output_0.data[idx + 3] = val.w;
}

void fgsr(float alpha) {
  ivec2 pos1 = ivec2(kGlobalId.xy);
  vec2 mv1 = readBuffer1(pos1.x, pos1.y).xy;
  float depth1 = readBuffer2(pos1.x, pos1.y).x;
  ivec2 pos0 = ivec2(pos1.x - mv1.x + 0.5, pos1.y + mv1.y + 0.5);
  vec2 mv0 = readBuffer0(pos0.x, pos0.y).xy;

  vec2 dm0 = -mv0, dm1 = -mv1;
  vec2 dm15 = 0.5 * (alpha * (3 * dm1 - dm0) + alpha * alpha * (dm1 - dm0));
  vec2 mv15 = -dm15;
  ivec2 pos15 = ivec2(pos1.x + mv15.x + 0.5, pos1.y - mv15.y + 0.5);

  int idx15 = indexBuffer(pos15.x, pos15.y);
  int idx1 = indexBuffer(pos1.x, pos1.y);
  output_0.data[idx1 + 3] = 1;

  float idepth = 1.f - depth1;
  atomicMax(output_0.data[idx15 + 2], idepth);
}

void main() {
  ivec2 cover_min = kGroupId.xy * kGroupSize.xy;
  ivec2 cover_max = cover_min + kGroupSize.xy - ivec2(1, 1);
  float alpha = 0.5;
  fgsr(alpha);
}