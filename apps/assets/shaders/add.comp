#version 450
#extension GL_EXT_shader_atomic_float2 : require
layout(local_size_x = 16, local_size_y = 16)in;

layout(set = 0, binding = 0)buffer InputBuffer0 {
  float data[];
} input_0;
layout(set = 0, binding = 1)buffer InputBuffer1 {
  float data[];
} input_1;
layout(set = 0, binding = 2)buffer InputBuffer2 {
  float data[];
} input_2;

layout(set = 1, binding = 0)buffer OutputBuffer0 {
  float data[];
} output_0;

layout(push_constant)uniform PushConstants {
  vec4 data1;
  vec4 data2;
  vec4 data3;
  vec4 data4;
} constants;

ivec3 kBufferSize = ivec3(constants.data1.xyz);
ivec3 kGroupSize = ivec3(gl_WorkGroupSize);
ivec3 kGroupNum = ivec3(gl_NumWorkGroups);
ivec3 kGroupId = ivec3(gl_WorkGroupID);
ivec3 kLocalId = ivec3(gl_LocalInvocationID);
// Current working element.
ivec3 kGlobalId = ivec3(gl_GlobalInvocationID);

int indexBuffer(int wi, int hi) {
  return hi * kBufferSize.x * kBufferSize.z + wi * kBufferSize.z;
}

vec4 readBuffer0(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_0.data[idx + 0],
    input_0.data[idx + 1],
    input_0.data[idx + 2],
    input_0.data[idx + 3]
  );
}
vec4 readBuffer1(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_1.data[idx + 0],
    input_1.data[idx + 1],
    input_1.data[idx + 2],
    input_1.data[idx + 3]
  );
}
vec4 readBuffer2(int wi, int hi) {
  int idx = indexBuffer(wi, hi);
  return vec4(
    input_2.data[idx + 0],
    input_2.data[idx + 1],
    input_2.data[idx + 2],
    input_2.data[idx + 3]
  );
}
void writeBuffer(int wi, int hi, vec4 val) {
  int idx = indexBuffer(wi, hi);
  output_0.data[idx + 0] = val.x;
  output_0.data[idx + 1] = val.y;
  output_0.data[idx + 2] = val.z;
  output_0.data[idx + 3] = val.w;
}

void main() {
  ivec2 cover_min = kGroupId.xy * kGroupSize.xy;
  ivec2 cover_max = cover_min + kGroupSize.xy - ivec2(1, 1);

  ivec2 pos_1 = ivec2(kGlobalId.xy);
  vec2 mv_1 = readBuffer1(pos_1.x, pos_1.y).xy;
  float depth_1 = readBuffer2(pos_1.x, pos_1.y).x;
  ivec2 pos_0 = pos_1 + ivec2(mv_1.x, mv_1.y);
  vec2 mv_0 = readBuffer0(pos_0.x, pos_0.y).xy;
  vec2 mv_15 = 0.5 * (0.5 * (3 * mv_1 - mv_0) + 0.5 * 0.5 * (mv_1 - mv_0));
  vec2 pos_15 = pos_1 + mv_15;
  int idx = indexBuffer(int(pos_15.x + 0.5), int(pos_15.y + 0.5));

  atomicMax(output_0.data[idx + 0], 1 - depth_1);
  atomicMax(output_0.data[idx + 1], 1 - depth_1);
  atomicMax(output_0.data[idx + 2], 1 - depth_1);

  barrier();
  memoryBarrierShared();

  // writeBuffer(cover_min.x, cover_min.y, vec4(kGroupId.xy, 1, 1));
  // writeBuffer(cover_max.x, cover_max.y, vec4(kGroupId.xy, 1, 1));
  // if (kLocalId.x == 0 && kLocalId.y == 0)
  // color = vec4(kGlobalId.xy, kGroupId.xy);
  // if (kLocalId.x == 15 && kLocalId.y == 15)
  // color = vec4(kGlobalId.xy, kGroupId.xy);

  // writeBuffer(kGlobalId.x, kGlobalId.y, color);
}